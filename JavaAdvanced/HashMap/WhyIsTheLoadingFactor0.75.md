# 加载因子为什么是0.75

HashMap是用数组+链表/红黑树实现的，我们想要往HashMap中添加数据（元素/键值对）或者取数据，就需要确定数据在数组中的下标（索引）。

加载因子是用来表示HashMap中的数据的填满程度：

> 加载因子=填入哈希表中的数据个数/哈希表的长度

这就意味着：

- 加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；

- 加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。

为了减少哈希冲突发生的概率，当HashMap的数组长度达到了一个**临界值**的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。

> 临界值=初始容量*加载因子

Java8之前，HashMap使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点(Node)过多时，链表会变得很长，查找的效率（LinkedList的查找效率为O(n)）就会受到影响。

Java8中，当链表的节点数超过一个阈值（8）时，链表转为红黑树（节点为TreeNode），红黑树是一种高效的平衡树结构，能够在O(log n)的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高HashMap的性能和可伸缩性。

考虑到HashMap的容量有一个要求：它必须是2的n次幂。当加载因子选择了0.75就可以保证它与容量的乘积为整数。

除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8 以下，超过 0.8，查表时的 CPU 缓存不命中（cache missing）会按照指数曲线上升。

综上，0.75 是个比较完美的选择。

## 小结

HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。

如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。

如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。

总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。